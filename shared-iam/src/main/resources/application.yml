# Spring Cloud Config Client configuration
spring:
  application:
    name: identity-service
  config:
    import: optional:configserver:http://localhost:8888
  cloud:
    config:
      fail-fast: false
  # Local fallback configuration
  datasource:
    url: jdbc:postgresql://localhost:5432/ecom_iam
    username: postgres
    password: postgres

# Local fallback configuration if Config Server is unavailable
server:
  port: 8081

# Password hashing configuration (Salt + Pepper with Argon2id)
password:
  # Pepper: Secret server-side value (NOT stored in database)
  # - Length: No limit! Can be 32, 64, 128+ bytes for maximum security
  # - Longer pepper = more entropy = stronger security
  # - Recommended: 32-64 bytes (256-512 bits)
  # - Generate with: openssl rand -base64 64  (for 64-byte pepper)
  # - Set via environment variable: export PASSWORD_PEPPER="your-long-random-string"
  pepper: ${PASSWORD_PEPPER:IpWqGDoY8MzVFGh36riE6Iy5jX4Ei4FOfx2TZeC6KhK5V1CotSUlNPfh+fAVRSP/87+JOXys54RCK8Ds+6ci1lbn7yGB174SEaQtZkYdFSvDuqckth3xDO1/7XgaFMNLXBRgl6OrC0jzU4G5e9I4ZKqT7adwj1f01XySV7ur4sU=}
  
argon2:
  # Salt length: 8-64 bytes (16 bytes/128 bits is standard, 32 bytes/256 bits is excellent, 64 bytes is overkill)
  # Current: 32 bytes (256 bits) - already MORE than industry standard!
  # Going higher (e.g., 64 bytes) provides minimal security benefit but increases storage
  salt-length: 32
  
  # Hash length: 16-64 bytes (32 bytes/256 bits is standard and sufficient)
  # Current: 32 bytes (256 bits) - provides 2^256 possible hash values (practically unbreakable)
  # Going higher provides no meaningful security benefit
  hash-length: 32
  
  parallelism: 1 # Number of parallel threads (1-4 recommended based on CPU cores)
  memory: 65536 # Memory cost in KB (64 MB) - good balance of security/performance
  iterations: 5 # Number of iterations (5-10 recommended for production, 3 is minimum)

logging:
  level:
    root: INFO
    com.ecom: DEBUG

# Application environment configuration
# WHAT: Determines if we're running in development or production
# HOW: Used by CookieService to set Secure flag (true in production, false in development)
# WHY: Cookies with Secure=true only work over HTTPS (required in production, breaks localhost HTTP)
# REAL-WORLD: Local development uses HTTP → Secure=false → Cookies work
#             Production uses HTTPS → Secure=true → Cookies work and are secure
app:
  environment: ${APP_ENVIRONMENT:development} # development or production
  
  # Cookie configuration for authentication
  # WHAT: Settings for httpOnly cookies that store authentication tokens
  # HOW: Used by CookieService to configure cookie domain, SameSite, etc.
  # WHY: Different environments (localhost vs Kubernetes) need different cookie settings
  # REAL-WORLD: Localhost doesn't need domain → Kubernetes needs domain for subdomain sharing
  cookie:
    # Cookie domain (for production Kubernetes deployment)
    # WHAT: Sets which domains can access the cookies
    # HOW: Browser only sends cookies to matching domains
    # WHY: Allows cookies to work across subdomains (e.g., api.example.com and www.example.com)
    # REAL-WORLD: 
    #   - Localhost: Leave empty (browser handles localhost automatically)
    #   - Kubernetes: Set to ".example.com" (allows api.example.com, www.example.com to share cookies)
    #   - Format: ".example.com" (leading dot = all subdomains) or "example.com" (exact domain only)
    # EXAMPLE: If your API is at api.myapp.com and frontend is at www.myapp.com, set to ".myapp.com"
    domain: ${APP_COOKIE_DOMAIN:}
    
    # SameSite=None for cross-domain scenarios
    # WHAT: Allows cookies to be sent in cross-site requests
    # HOW: Sets SameSite=None (requires Secure=true, which requires HTTPS)
    # WHY: Only needed if frontend and backend are on completely different domains
    # REAL-WORLD: 
    #   - Same domain (api.example.com + www.example.com): false (use SameSite=Lax, default)
    #   - Different domains (api.example.com + frontend.otherdomain.com): true (use SameSite=None)
    # NOTE: If true, you MUST use HTTPS (Secure=true) and set cookie domain properly
    same-site-none: ${APP_COOKIE_SAME_SITE_NONE:false}

# JWT token configuration
jwt:
  access-token:
    expiry-hours: 2 # Short-lived for security (auto-refreshed via refresh token)
  refresh-token:
    expiry-days: 30 # Long-lived for UX (users stay logged in for 30 days)

